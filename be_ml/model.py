"""model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vLiS9V-Y1OJfG3SoZUBH8WWxbLpn_9-n
"""

"""## 1. Tạo dữ liệu mẫu

### a. Tạo dữ liệu không có lỗi theo phân phối
"""

import numpy as np
import pandas as pd
import warnings
warnings.filterwarnings("ignore") # Bỏ qua warning

# config
N = 100000
INTERVAL = 30 # giây
START_TIMESTAMP = 1700000000  # giả lập

# Settings threshold
SOIL_LOW = 55
SOIL_HIGH = 65
TEMP_HIGH = 28
HUMID_LOW = 70

# Base values
BASE_TEMP = 27
BASE_HUMID = 75
AMP = 4                  # biên độ ngày–đêm
NOISE_STD = 0.3

# Irrigation parameters
IRRIGATION_RATE = 0.15
EVAP_BASE = 0.008

np.random.seed(42)

timestamps = np.arange(
    START_TIMESTAMP,
    START_TIMESTAMP + N * INTERVAL,
    INTERVAL
)
timestamps[0:10]

# AIR TEMPERATURE & HUMIDITY

t = np.arange(N) * INTERVAL

# chu kỳ ngày đêm (86400s)
daily_cycle = np.sin(2 * np.pi * t / 86400)
seasonal = 5 * np.sin(2 * np.pi * t / (86400 * 90))  # chu kỳ ~3 tháng lệch khoảng 5 độ
temp_air = (
    BASE_TEMP
    + AMP * daily_cycle
    + seasonal
    + np.random.normal(0, NOISE_STD, N)
)

temp_air = np.clip(temp_air, 15, 40)

humidity_air = (
    BASE_HUMID
    - 0.6 * (temp_air - BASE_TEMP)
    + np.random.normal(0, 1.0, N)
)

humidity_air = np.clip(humidity_air, 30, 95)

print(temp_air[0:10])
print(humidity_air[0:10])

soil = np.zeros(N)
irrigation = np.zeros(N)

soil[0] = 55.0  # Bắt đầu ở giữa range

for i in range(1, N):
    # Evaporation phụ thuộc nhiệt độ & độ ẩm không khí
    temp_factor = 1 + 0.05 * (temp_air[i] - BASE_TEMP)
    humid_factor = 1 - 0.01 * (humidity_air[i] - BASE_HUMID)
    evap_rate = EVAP_BASE * temp_factor * humid_factor

    soil[i] = soil[i - 1] - evap_rate

    # Control logic với hysteresis
    # Chỉ tưới khi THỰC SỰ khô và điều kiện môi trường xấu
    if soil[i] < SOIL_LOW:
        if temp_air[i] > TEMP_HIGH or humidity_air[i] < HUMID_LOW:
            irrigation[i] = 1
        else:
            # Nếu ...
            irrigation[i] = 1 if soil[i] < SOIL_LOW - 5 else irrigation[i - 1]
    elif soil[i] >= SOIL_HIGH:
        irrigation[i] = 0
    else:
        # Giữ nguyên trạng thái trong vùng hysteresis
        irrigation[i] = irrigation[i - 1]

    # Irrigation effect: độ ẩm + 1 ít + nhiễu cảm biến
    if irrigation[i] == 1:
        soil[i] += IRRIGATION_RATE + np.random.uniform(-0.002, 0.002)

    soil[i] = np.clip(soil[i], 5, 100)

# WATER LEVEL

water = np.zeros(N)
water[0] = 100.0

refilling = False
for i in range(1, N):
    water[i] = water[i - 1]
    if irrigation[i] == 1 and water[i] > 0:
        water[i] -= np.random.uniform(0.1, 0.3)

    water[i] = max(water[i], 0)
    # nếu mực nước bằng 0 và giờ đo nằm trong khoảng từ 18-21 giờ (đi làm về :v) thì fill nước
    hour = pd.to_datetime(timestamps[i], unit="s").hour
    if water[i] == 0 and 18 <= hour <= 21 and not refilling:
        if np.random.rand() > 0.5:
            refilling = True

    if refilling:
        water[i] += 10
        if water[i] >= 100:
            water[i] = 100
            refilling = False

df = pd.DataFrame({
    "timestamp": timestamps,
    "temp_air": temp_air,
    "humidity_air": humidity_air,
    "soil_moisture": soil,
    "water_level": water
})

"""### b. Xem phân phối synthetic data"""
df["timestamp"] = pd.to_datetime(
    df["timestamp"],
    unit="s"
)

df = df.sort_values("timestamp").reset_index(drop=True)
print(df.describe())


features = ['temp_air', 'humidity_air', 'soil_moisture', 'water_level']

# lấy 80% dữ liệu của df làm train
train_size = int(0.8 * len(df))
train_df = df[:train_size]
test_df_normaly = df[train_size:]

"""### c. Tạo lỗi dữ liệu

- Stuck: cảm biến dừng ở một giá trị nhiều lần liên tục.

- Spike: cảm biến tăng/giảm đột biến.

- Drift: phân phối dữ liệu dịch dần theo thời gian.

- Dropout: cảm biến bị mất(giá trị = 0).
"""

def inject_anomalies(
    x,
    anomaly_ratio=0.1,
    min_event_len=5,
    max_event_len=40,
    seed=42
):
    """
    x: np.ndarray (N,)
    anomaly_ratio: tỉ lệ mẫu lỗi (vd 0.02 = 2%)
    """

    rng = np.random.default_rng(seed)
    N = len(x)

    x_anom = x.copy()
    labels = np.zeros(N, dtype=int)

    target_anomaly_points = int(N * anomaly_ratio)
    current_anomaly_points = 0

    anomaly_types = ["stuck", "spike", "drift", "dropout"]

    while current_anomaly_points < target_anomaly_points:
        start = rng.integers(0, N - 1)
        length = rng.integers(min_event_len, max_event_len + 1)
        end = min(start + length, N)

        # giả sử một thời điểm chỉ có thể xảy ra 1 loại lỗi cảm biến
        if labels[start:end].sum() > 0:
            continue

        err_type = rng.choice(anomaly_types)

        if err_type == "stuck":
            x_anom[start:end] = x_anom[start]

        elif err_type == "spike":
            spike = rng.normal(0, 3 * np.std(x), end - start)
            x_anom[start:end] += spike

        elif err_type == "drift":
            drift = np.linspace(
                0,
                rng.uniform(2, 6),
                end - start
            )
            x_anom[start:end] += drift

        elif err_type == "dropout":
            x_anom[start:end] = 0

        labels[start:end] = 1
        current_anomaly_points += (end - start)

    return x_anom, labels

temp_faulty, temp_labels = inject_anomalies(
    test_df_normaly['temp_air'].values,
    anomaly_ratio=0.1
)

humidity_faulty, humidity_labels = inject_anomalies(
    test_df_normaly['humidity_air'].values,
    anomaly_ratio=0.1
)

soil_faulty, soil_labels = inject_anomalies(
    test_df_normaly['soil_moisture'].values,
    anomaly_ratio=0.1
)

water_faulty, water_labels = inject_anomalies(
    test_df_normaly['water_level'].values,
    anomaly_ratio=0.1
)

test_df_faulty = pd.DataFrame({
    "timestamp": test_df_normaly['timestamp'],
    "temp_air": temp_faulty,
    "humidity_air": humidity_faulty,
    "soil_moisture": soil_faulty,
    "water_level": water_faulty,
    "temp_labels": temp_labels,
    "humidity_labels": humidity_labels,
    "soil_labels": soil_labels,
    "water_labels": water_labels
})

test_df_faulty.shape

"""# 2. Train mô hình"""

from sklearn.preprocessing import StandardScaler

from tensorflow.keras.layers import Input, LSTM, Dense, TimeDistributed, RepeatVector
from tensorflow.keras.models import Model
from sklearn.metrics import classification_report
import joblib

"""## a. SEPARATE AUTOENCODER MODELS"""

def build_single_sensor_autoencoder(window_size=30, latent_dim=12):
    """
    Autoencoder cho 1 sensor.

    Input:  (batch, 30, 1)  ← Chỉ 1 sensor
    Output: (batch, 30, 1)
    """

    inputs = Input(shape=(window_size, 1))

    # Encoder
    encoded = LSTM(latent_dim, activation='tanh', return_sequences=False)(inputs)

    # Decoder
    decoded = RepeatVector(window_size)(encoded)
    decoded = LSTM(latent_dim, activation='tanh', return_sequences=True)(decoded)
    outputs = TimeDistributed(Dense(1))(decoded)

    model = Model(inputs, outputs)
    model.compile(optimizer='adam', loss='mse')

    return model

def train_3_separate_autoencoders(
    df_train,
    features=['temp_air', 'humidity_air', 'soil_moisture', 'water_level'],
    window_size=30
):
    """
    Train 3 autoencoder riêng:
    - Model 1: Air (temp + humid combined)
    - Model 2: Soil
    - Model 3: Water
    """
    print("="*80)
    print("TRAIN 3 SEPARATE AUTOENCODER MODELS")
    print("="*80)


    # Scalers
    scaler_air = StandardScaler()
    scaler_soil = StandardScaler()
    scaler_water = StandardScaler()

    # Fit scalers
    scaler_air.fit(df_train[['temp_air', 'humidity_air']].values)
    scaler_soil.fit(df_train[['soil_moisture']].values)
    scaler_water.fit(df_train[['water_level']].values)

    # Prepare data
    air_data = scaler_air.transform(df_train[['temp_air', 'humidity_air']].values)
    soil_data = scaler_soil.transform(df_train[['soil_moisture']].values)
    water_data = scaler_water.transform(df_train[['water_level']].values)

    # Create windows
    def create_windows(data, window_size=30, stride=1):
        X = []
        for i in range(0, len(data) - window_size + 1, stride):
            X.append(data[i:i + window_size])
        return np.array(X)

    X_air = create_windows(air_data, window_size)      # (n, 30, 2)
    X_soil = create_windows(soil_data, window_size)    # (n, 30, 1)
    X_water = create_windows(water_data, window_size)  # (n, 30, 1)

    # === Train Model 1: Air ===
    print("\n### Training Model 1: Air (temp + humid) ###")
    model_air = build_single_sensor_autoencoder(window_size, latent_dim=24)

    # Need to reshape for 2 features
    inputs_air = Input(shape=(window_size, 2))
    encoded_air = LSTM(8, activation='tanh', return_sequences=False)(inputs_air)
    decoded_air = RepeatVector(window_size)(encoded_air)
    decoded_air = LSTM(8, activation='tanh', return_sequences=True)(decoded_air)
    outputs_air = TimeDistributed(Dense(2))(decoded_air)
    model_air = Model(inputs_air, outputs_air)
    model_air.compile(optimizer='adam', loss='mse')

    model_air.fit(X_air, X_air, epochs=20, batch_size=128, validation_split=0.2, verbose=0)
    print("Air model trained")

    # === Train Model 2: Soil ===
    print("\n### Training Model 2: Soil ###")
    model_soil = build_single_sensor_autoencoder(window_size, latent_dim=8)
    model_soil.fit(X_soil, X_soil, epochs=20, batch_size=128, validation_split=0.2, verbose=0)
    print("Soil model trained")

    # === Train Model 3: Water ===
    print("\n### Training Model 3: Water ###")
    model_water = build_single_sensor_autoencoder(window_size, latent_dim=8)
    model_water.fit(X_water, X_water, epochs=20, batch_size=128, validation_split=0.2, verbose=0)
    print("Water model trained")

    print("\n" + "="*80)
    print("ALL 3 MODELS TRAINED")
    print("="*80)

    models = {
        'air': model_air,
        'soil': model_soil,
        'water': model_water
    }

    scalers = {
        'air': scaler_air,
        'soil': scaler_soil,
        'water': scaler_water
    }

    return models, scalers

ae_models, ae_scalers = train_3_separate_autoencoders(train_df)



def calculate_3_thresholds(
    models,
    scalers,
    df_train,
    features=['temp_air', 'humidity_air', 'soil_moisture', 'water_level'],
    window_size=30,
    percentile=95
):
    """
    Calculate thresholds cho cả 3 models.

    Parameters:
    -----------
    models : dict
        {'air': model_air, 'soil': model_soil, 'water': model_water}
    scalers : dict
        {'air': scaler_air, 'soil': scaler_soil, 'water': scaler_water}

    Returns:
    --------
    thresholds : dict
        {'air': 0.025, 'soil': 0.032, 'water': 0.018}
    """
    print("="*80)
    print("STEP 1: CALCULATE THRESHOLDS FOR 3 MODELS")
    print("="*80)

    thresholds = {}

    # === Model 1: Air (temp + humid) ===
    print("\n### Model 1: Air (temp + humid) ###")

    # Prepare air data
    air_data = df_train[['temp_air', 'humidity_air']].values
    air_scaled = scalers['air'].transform(air_data)

    # Create windows
    X_air = []
    for i in range(len(air_scaled) - window_size):
        X_air.append(air_scaled[i:i+window_size])
    X_air = np.array(X_air)

    # Reconstruct
    X_air_recon = models['air'].predict(X_air, verbose=0)

    # Calculate errors
    errors_air = np.abs(X_air - X_air_recon).mean(axis=(1, 2))
    thresholds['air'] = np.percentile(errors_air, percentile)

    print(f"Air threshold ({percentile}th): {thresholds['air']:.6f}")
    print(f"  Mean error: {errors_air.mean():.6f}")
    print(f"  Std error:  {errors_air.std():.6f}")

    # === Model 2: Soil ===
    print("\n### Model 2: Soil Moisture ###")

    soil_data = df_train[['soil_moisture']].values
    soil_scaled = scalers['soil'].transform(soil_data)

    X_soil = []
    for i in range(len(soil_scaled) - window_size):
        X_soil.append(soil_scaled[i:i+window_size])
    X_soil = np.array(X_soil)

    X_soil_recon = models['soil'].predict(X_soil, verbose=0)
    errors_soil = np.abs(X_soil - X_soil_recon).mean(axis=(1, 2))
    thresholds['soil'] = np.percentile(errors_soil, percentile)

    print(f"Soil threshold ({percentile}th): {thresholds['soil']:.6f}")
    print(f"  Mean error: {errors_soil.mean():.6f}")
    print(f"  Std error:  {errors_soil.std():.6f}")

    # === Model 3: Water ===
    print("\n### Model 3: Water Level ###")

    water_data = df_train[['water_level']].values
    water_scaled = scalers['water'].transform(water_data)

    X_water = []
    for i in range(len(water_scaled) - window_size):
        X_water.append(water_scaled[i:i+window_size])
    X_water = np.array(X_water)

    X_water_recon = models['water'].predict(X_water, verbose=0)
    errors_water = np.abs(X_water - X_water_recon).mean(axis=(1, 2))
    thresholds['water'] = np.percentile(errors_water, percentile)

    print(f"Water threshold ({percentile}th): {thresholds['water']:.6f}")
    print(f"  Mean error: {errors_water.mean():.6f}")
    print(f"  Std error:  {errors_water.std():.6f}")

    print("\n" + "="*80)
    print("THRESHOLDS CALCULATED")
    print("="*80)
    print(f"Air:   {thresholds['air']:.6f}")
    print(f"Soil:  {thresholds['soil']:.6f}")
    print(f"Water: {thresholds['water']:.6f}")

    return thresholds

thresholds = calculate_3_thresholds(ae_models, ae_scalers, train_df)

def evaluate_3models_on_testset(
    models,
    scalers,
    thresholds,
    df_test_faulty,
    features=['temp_air', 'humidity_air', 'soil_moisture', 'water_level'],
    window_size=30,
    stride=1
):
    """
    Evaluate 3 models trên test set.
    """
    print("="*80)
    print("STEP 3: EVALUATE 3 MODELS ON TEST SET")
    print("="*80)

    # Prepare test data
    print("\nPreparing test windows...")

    test_data = df_test_faulty[features].values

    windows = []
    y_true = {'air': [], 'soil': [], 'water': []}

    for start in range(0, len(test_data) - window_size + 1, stride):
        end = start + window_size
        windows.append(test_data[start:end])

        # Calculate labels for 3 sensors
        error_mask = df_test_faulty[["temp_labels", "humidity_labels", "soil_labels", "water_labels"]]
        window_mask = error_mask.iloc[start:end]

        # Sensor 0: Air (temp OR humid có lỗi)
        air_fault = window_mask['temp_labels'].any() or window_mask['humidity_labels'].any()

        # Sensor 1: Soil
        soil_fault = window_mask['soil_labels'].any()

        # Sensor 2: Water
        water_fault = window_mask['water_labels'].any()

        y_true['air'].append(int(air_fault))
        y_true['soil'].append(int(soil_fault))
        y_true['water'].append(int(water_fault))

    windows = np.array(windows)
    for key in y_true:
        y_true[key] = np.array(y_true[key])

    print(f"Created {len(windows)} test windows")
    print(f"\nGround truth distribution:")
    print(f"  Air:   {y_true['air'].sum()}/{len(y_true['air'])} ({y_true['air'].mean()*100:.1f}%) faulty")
    print(f"  Soil:  {y_true['soil'].sum()}/{len(y_true['soil'])} ({y_true['soil'].mean()*100:.1f}%) faulty")
    print(f"  Water: {y_true['water'].sum()}/{len(y_true['water'])} ({y_true['water'].mean()*100:.1f}%) faulty")

    # Detect on all windows
    print("\nDetecting faults...")

    y_pred = {'air': [], 'soil': [], 'water': []}

    batch_air_scaled = ae_scalers['air'].transform(windows[:, :, [0, 1]].reshape(-1, 2)).reshape(-1, 30, 2)
    batch_soil_scaled = ae_scalers['soil'].transform(windows[:, :, [2]].reshape(-1, 1)).reshape(-1, 30, 1)
    batch_water_scaled = ae_scalers['water'].transform(windows[:, :, [3]].reshape(-1, 1)).reshape(-1, 30, 1)

    w_hat_air = ae_models['air'].predict(batch_air_scaled, verbose=0)
    w_hat_soil = ae_models['soil'].predict(batch_soil_scaled, verbose=0)
    w_hat_water = ae_models['water'].predict(batch_water_scaled, verbose=0)

    w_err_air = np.mean(np.abs(batch_air_scaled - w_hat_air), axis=(1, 2))
    w_err_soil = np.mean(np.abs(batch_soil_scaled - w_hat_soil), axis=(1, 2))
    w_err_water = np.mean(np.abs(batch_water_scaled - w_hat_water), axis=(1, 2))

    y_pred['air'] = (w_err_air > thresholds['air']).astype(int)
    y_pred['soil'] = (w_err_soil > thresholds['soil']).astype(int)
    y_pred['water'] = (w_err_water > thresholds['water']).astype(int)

    for key in y_pred:
        y_pred[key] = np.array(y_pred[key])

    # Evaluate each sensor
    sensor_names = {
        'air': 'Air (temp+humid)',
        'soil': 'Soil moisture',
        'water': 'Water level'
    }

    for key, name in sensor_names.items():
        print("\n" + "="*80)
        print(f"{name.upper()}")
        print("="*80)

        print(classification_report(
            y_true[key],
            y_pred[key],
            target_names=['Normal', 'Faulty'],
            digits=3
        ))

    return y_true, y_pred

y_trues, y_preds = evaluate_3models_on_testset(
    ae_models,
    ae_scalers,
    thresholds,
    test_df_faulty
)

def inject_single_anomalies (data, err_type, anomaly_length = 5):
    rng = np.random.default_rng(42)
    N = len(data)

    data_anom = data.copy()

    # đảm bảo start không quá 30, nhưng nếu anomaly_length = 30 thì có nghĩa là lỗi cả window
    if anomaly_length > 30:
        anomaly_length = 30

    start = rng.integers(0, N - anomaly_length + 1)
    end = start + anomaly_length

    if err_type == "stuck":
        data_anom[start:end] = data_anom[start]

    if err_type == "spike":
        spike = rng.normal(0, 3 * np.std(data), end - start)
        data_anom[start:end] += spike

    if err_type == "drift":
        drift = np.linspace(
            0,
            rng.uniform(2, 6),
            end - start
        )
        data_anom[start:end] += drift

    if err_type == "dropout":
        data_anom[start:end] = 0

    return data_anom

def detect_3sensors_faults(
    window,
    features=['temp_air', 'humidity_air', 'soil_moisture', 'water_level'],
    models=None,
    scalers=None,
    thresholds=None
):
    """
    Detect faults sử dụng 3 models riêng.

    Parameters:
    -----------
    window : array (30, 4) or DataFrame
        Window data với 4 features
    models : dict
        {'air': model, 'soil': model, 'water': model}
    scalers : dict
        {'air': scaler, 'soil': scaler, 'water': scaler}
    thresholds : dict
        {'air': 0.025, 'soil': 0.032, 'water': 0.018}

    Returns:
    --------
    result : dict
        {
            'Air (temp+humid)': {'error': 0.02, 'threshold': 0.025, 'fault': False},
            'Soil moisture': {'error': 0.05, 'threshold': 0.032, 'fault': True},
            'Water level': {'error': 0.01, 'threshold': 0.018, 'fault': False}
        }
    """
    if isinstance(window, pd.DataFrame):
        window = window.values

    if window.shape != (30, 4):
        raise ValueError(f"Window must be (30, 4), got {window.shape}")

    result = {}

    # === Sensor 1: Air (temp + humid) ===
    air_data = window[:, [0, 1]]  # temp_air, humidity_air
    air_scaled = scalers['air'].transform(air_data)
    air_recon = models['air'].predict(air_scaled[None, ...], verbose=0)[0]
    error_air = np.abs(air_scaled - air_recon).mean()

    result['Air (temp+humid)'] = {
        'error': float(error_air),
        'threshold': float(thresholds['air']),
        'fault': bool(error_air > thresholds['air']),
        'severity': float(error_air / thresholds['air'])
    }

    # === Sensor 2: Soil ===
    soil_data = window[:, [2]]  # soil_moisture
    soil_scaled = scalers['soil'].transform(soil_data)
    soil_recon = models['soil'].predict(soil_scaled[None, ...], verbose=0)[0]
    error_soil = np.abs(soil_scaled - soil_recon).mean()

    result['Soil moisture'] = {
        'error': float(error_soil),
        'threshold': float(thresholds['soil']),
        'fault': bool(error_soil > thresholds['soil']),
        'severity': float(error_soil / thresholds['soil'])
    }

    # === Sensor 3: Water ===
    water_data = window[:, [3]]  # water_level
    water_scaled = scalers['water'].transform(water_data)
    water_recon = models['water'].predict(water_scaled[None, ...], verbose=0)[0]
    error_water = np.abs(water_scaled - water_recon).mean()

    result['Water level'] = {
        'error': float(error_water),
        'threshold': float(thresholds['water']),
        'fault': bool(error_water > thresholds['water']),
        'severity': float(error_water / thresholds['water'])
    }

    return result

def scenarios_test_comprehensive(X_window, model_check_func=detect_3sensors_faults):
    """
    Thực hiện kiểm thử sơ bộ với các kịch bản lỗi hỗn hợp (mixed faults)
    trên 4 đặc trưng.

    X_window: Cửa sổ dữ liệu sạch (30, 4)
    model_check_func: Hàm kiểm tra lỗi (check_window_fault)
    """

    # Định nghĩa các loại lỗi và đặc trưng
    FAULT_TYPES = ["stuck", "spike", "drift", "dropout"]
    FEATURE_MAP = {
        0: "temp_air",
        1: "humidity_air",
        2: "soil_moisture",
        3: "water_level"
    }
    ALL_FEATURES = [0, 1, 2, 3] # Chỉ số các cột
    rng_test = np.random.default_rng(2025) # Seed mới cho kịch bản test

    # --- 1. SCENARIO: NO FAULT (1 lần) ---
    print("\n" + "="*80)
    print("1. KỊCH BẢN: KHÔNG LỖI")
    print("="*80)
    print("Th1: Normal (Tất cả sensor sạch)")
    result_no_fault = detect_3sensors_faults(X_window,models=ae_models, scalers=ae_scalers, thresholds=thresholds)
    print(f"Air: {result_no_fault['Air (temp+humid)']['fault']}", )
    print(f"Soil: {result_no_fault['Soil moisture']['fault']}")
    print(f"Water: {result_no_fault['Water level']['fault']}")


    # --- 2. SCENARIO: SINGLE SENSOR FAULTY (3 lần) ---
    print("\n" + "="*80)
    print("2. KỊCH BẢN: CHỈ 1 SENSOR LỖI (3 LẦN)")
    print("="*80)

    tested_single_features = []

    for i in range(1, 4):
        # Chọn một feature chưa được test
        available_features = [f for f in ALL_FEATURES if f not in tested_single_features]
        if not available_features:
            available_features = ALL_FEATURES

        target_feature = rng_test.choice(available_features)
        tested_single_features.append(target_feature)

        fault_type = rng_test.choice(FAULT_TYPES)
        X_window_faulty = X_window.copy()

        # Tiêm lỗi
        X_window_faulty[:, target_feature] = inject_single_anomalies(
            data=X_window[:, target_feature],
            err_type=fault_type
        )

        print(f"Th2.{i}: Lỗi Đơn ở {FEATURE_MAP[target_feature]} (Loại: {fault_type})")
        result_1fault = detect_3sensors_faults(X_window_faulty, models=ae_models, scalers=ae_scalers, thresholds=thresholds)
        print(f"Air: {result_1fault['Air (temp+humid)']['fault']}")
        print(f"Soil: {result_1fault['Soil moisture']['fault']}")
        print(f"Water: {result_1fault['Water level']['fault']}")


    # --- 3. SCENARIO: TWO SENSORS FAULTY (3 lần) ---
    print("\n" + "="*80)
    print("3. KỊCH BẢN: 2 SENSOR LỖI (3 LẦN)")
    print("="*80)

    for i in range(1, 4):
        # Chọn hai feature duy nhất
        target_features = rng_test.choice(ALL_FEATURES, size=2, replace=False)

        X_window_faulty = X_window.copy()
        scenario_desc = []

        for feature_index in target_features:
            fault_type = rng_test.choice(FAULT_TYPES)
            X_window_faulty[:, feature_index] = inject_single_anomalies(
                data=X_window[:, feature_index],
                err_type=fault_type
            )
            scenario_desc.append(f"{FEATURE_MAP[feature_index]} ({fault_type})")

        print(f"Th3.{i}: Lỗi Kép: {', '.join(scenario_desc)}")
        results_2faults = detect_3sensors_faults(X_window_faulty,models=ae_models, scalers=ae_scalers, thresholds=thresholds)
        print(f"Air: {results_2faults['Air (temp+humid)']['fault']}")
        print(f"Soil: {results_2faults['Soil moisture']['fault']}")
        print(f"Water: {results_2faults['Water level']['fault']}")

    # --- 4. SCENARIO: THREE SENSORS FAULTY (3 lần) ---
    print("\n" + "="*80)
    print("4. KỊCH BẢN: 3 SENSOR LỖI (3 LẦN)")
    print("="*80)

    for i in range(1, 4):
        # Chọn ba feature duy nhất
        target_features = rng_test.choice(ALL_FEATURES, size=3, replace=False)

        X_window_faulty = X_window.copy()
        scenario_desc = []

        for feature_index in target_features:
            fault_type = rng_test.choice(FAULT_TYPES)
            X_window_faulty[:, feature_index] = inject_single_anomalies(
                data=X_window[:, feature_index],
                err_type=fault_type
            )
            scenario_desc.append(f"{FEATURE_MAP[feature_index]} ({fault_type})")

        print(f"Th4.{i}: Lỗi Ba: {', '.join(scenario_desc)}")
        results_3faults = detect_3sensors_faults(X_window_faulty,models=ae_models, scalers=ae_scalers, thresholds=thresholds)
        print(f"Air: {results_3faults['Air (temp+humid)']['fault']}")
        print(f"Soil: {results_3faults['Soil moisture']['fault']}")
        print(f"Water: {results_3faults['Water level']['fault']}")

def save_3models_system(models, scalers, thresholds):
    """
    Save 3 models + scalers + thresholds.
    """

    print("="*80)
    print("STEP 4: SAVE MODELS, SCALERS, THRESHOLDS")
    print("="*80)

    # Save models
    models['air'].save(f'air_model.h5')
    models['soil'].save(f'soil_model.h5')
    models['water'].save(f'water_model.h5')

    # Save scalers
    joblib.dump(scalers['air'], f'air_scaler.joblib')
    joblib.dump(scalers['soil'], f'soil_scaler.joblib')
    joblib.dump(scalers['water'], f'water_scaler.joblib')

    # Save thresholds
    np.save(f'thresholds.npy', thresholds)

    print(f"\nSaved files:")
    print("     - air_model.h5")
    print("     - soil_model.h5")
    print("     - water_model.h5")
    print("   Scalers:")
    print("     - air_scaler.joblib")
    print("     - soil_scaler.joblib")
    print("     - water_scaler.joblib")
    print("   Thresholds:")
    print("     - thresholds.npy")